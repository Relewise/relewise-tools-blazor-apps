@using KristofferStrube.DocumentSearching
@using Newtonsoft.Json
@using Newtonsoft.Json.Converters
@using global::Relewise.Client.Requests.Search
@using global::Relewise.Client.Search

@if (Request is not ProductSearchRequest)
{
    return;
}

<h2>Troubleshooter (<code>Experimental</code>)</h2>
<p>We can do a bit of analysis which might make troublshooting easier. Try it out!</p>

@if (error is not null)
{
    <code>@error</code>
    <br />
    <br />
}
@if (message is not null)
{
    <span style="color:green;">@message</span>
    <br />
    <br />
}
@if (StaticDatasetStorage.ParentOrigin is null || string.IsNullOrWhiteSpace(StaticDatasetStorage.ApiKey))
{
    <p>
        First you need to insert your Server URL, Dataset Id, and API Key to connect with your dataset. You can find these at <a target="_blank" href="https://my.relewise.com/api-keys">My Relewise > API Keys</a>.
        <br />
        <small>You can't use your Master key in this application so you will have to create some separate key that can use the <code>Searcher</code>, <code>DataAccessor</code>, and <code>Search Administrator</code>, and listing all merchandising rules.</small>
    </p>

    <ConnectionCredentials />
}

@if (searcher is null)
{
    <button class="btn btn-success" @onclick="Connect">Connect</button>
    <br />
    return;
}
else
{
    <button class="btn btn-success" @onclick="ExecuteRequest">Make Request Again</button>
    <br />
}
<br />

@if (improvements?.Count > 0)
{
    <ul>
        @foreach (var improvement in improvements.OrderByDescending(i => i.Severity))
        {
            <li style="color: @SeverityColor(improvement.Severity)">@improvement.Message</li>
        }
    </ul>
}

@if (results?.Length is 0)
{
    <h4>There were no results</h4>
}
else if (results?.Length > 0)
{
    <div class="grid big-grid">
        @foreach (var result in results)
        {
            <div class="position">
                @(result.Position).<br />
                <small style="color:green;" title="It's ranking among the 1000 first result only with regards to relevance to the user; Not textual match.">(@result.PopularityIndex)</small>
            </div>

            <div class="card" @key=@result>
                <div class="header">
                    <div class="name">
                        @result.ProductId @(result.VariantId is not null ? " — " + result.VariantId : "") &nbsp;
                    </div>
                    <div class="icons">
                        @foreach (var ruleSummary in result.MerchandisingRules)
                        {
                            var differenceInPosition = resultsWithoutMerchandisingRule.TryGetValue(ruleSummary.Rule, out var resultsWithoutBoostOrBurry)
                            && resultsWithoutBoostOrBurry.FirstOrDefault(r => r == (result.ProductId, result.VariantId)) is { } resultInListWithoutMerchandisingRule
                            ? (resultsWithoutBoostOrBurry.IndexOf(resultInListWithoutMerchandisingRule) - results.ToList().IndexOf(result)) : 0;

                            <div class="icon purple" title="Matched conditions for Merchandising Rule: @ruleSummary.Name - @(ruleSummary.Description). It would have been @(differenceInPosition == 0 ? "in the same position without this rule (this is a guess)." : differenceInPosition > 0 ? Math.Abs(differenceInPosition) + $" position{(Math.Abs(differenceInPosition) is 1 ? "" : "s")} lower without this rule." : Math.Abs(differenceInPosition) + $" position{(Math.Abs(differenceInPosition) is 1 ? "" : "s")} higher without this rule.")">
                                @differenceInPosition
                                <svg width="20" class="bi" viewBox="0 0 16 16">
                                    <polygon stroke="#FFFFFF" stroke-width="2" fill="none" points="8,1 6,6 1,6 5,9 3,14 8,11 13,14 11,9 15,6 10,6" stroke-linecap="round" stroke-linejoin="round"></polygon>
                                </svg>
                            </div>
                        }
                    </div>
                </div>
                <div class="content grid">
                    @foreach (var indexedValue in result.IndexedValues)
                    {
                        <b title="Has weight @indexedValue.Weight"> @indexedValue.Name</b>
                        <div @key=indexedValue>
                            @if (indexedValue.TermMatches is not { } matches)
                            {
                                @indexedValue.Content
                            }
                            else
                            {
                                @for (int i = 0; i < indexedValue.Content.Length; i++)
                                {
                                    if (matches.FirstOrDefault(m => i == m.Position) is { } match && match.Length is not 0)
                                    {
                                        int offset = 0;
                                        for (int j = 0; j < match.ExpandedCigar.Length && i + j + offset < indexedValue.Content.Length; j++)
                                        {
                                            if (match.ExpandedCigar[j] is EditType.Match)
                                            {
                                                <span style="background-color:#9F9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.MisMatch)
                                            {
                                                <span style="background-color:#EE9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.Insert)
                                            {
                                                <span style="background-color:#EE9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.Delete)
                                            {
                                                offset--;
                                            }
                                        }
                                        i += match.Length - 1;
                                    }
                                    else
                                    {
                                        int nextMatch = matches.FirstOrDefault(m => m.Position >= i).Position;
                                        if (nextMatch != 0)
                                        {
                                            <span>@indexedValue.Content[i..(nextMatch)]</span>
                                            i = nextMatch - 1;
                                        }
                                        else
                                        {
                                            <span>@indexedValue.Content[i..]</span>
                                            i = indexedValue.Content.Length;
                                        }
                                    }
                                }
                            }
                        </div>
                    }
                </div>
            </div>
        }
    </div>
}

