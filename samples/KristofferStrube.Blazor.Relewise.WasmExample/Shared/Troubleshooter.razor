@using KristofferStrube.DocumentSearching
@using Newtonsoft.Json
@using Newtonsoft.Json.Converters
@using global::Relewise.Client.Requests.Search
@using global::Relewise.Client.Search

@if (Request is not ProductSearchRequest)
{
    return;
}

<h2>Troubleshooter (<code>Experimental</code>)</h2>
<p>We can do a bit of analysis which might make troublshooting easier. Try it out!</p>

@if (error is not null)
{
    <code>@error</code>
    <br />
    <br />
}
@if (message is not null)
{
    <span style="color:green;">@message</span>
    <br />
    <br />
}
@if (StaticDatasetStorage.ParentOrigin is null || string.IsNullOrWhiteSpace(StaticDatasetStorage.ApiKey))
{
    <p>
        First you need to insert your Server URL, Dataset Id, and API Key to connect with your dataset. You can find these at <a target="_blank" href="https://my.relewise.com/api-keys">My Relewise > API Keys</a>.
        <br />
        <small>You can't use your Master key in this application so you will have to create some separate key that can use the <code>Searcher</code>, <code>DataAccessor</code>, and <code>Search Administrator</code>.</small>
    </p>

    <ConnectionCredentials />
}

@if (searcher is null)
{
    <button class="btn btn-success" @onclick="Connect">Connect</button>
    <br />
    return;
}
else
{
    <button class="btn btn-success" @onclick="ExecuteRequest">Make Request Again</button>
    <br />
}
<br />

@if (improvements?.Count > 0)
{
    <ul>
        @foreach (var improvement in improvements.OrderByDescending(i => i.Severity))
        {
            <li style="color: @SeverityColor(improvement.Severity)">@improvement.Message</li>
        }
    </ul>
}

@if (results?.Length is 0)
{
    <h4>There were no results</h4>
}
else if (results?.Length > 0)
{
    <div class="grid">
        @foreach (var result in results)
        {
            <div class="position">
                @(result.Position).<br />
                <small style="color:green;" title="It's ranking among the 1000 first result only with regards to relevance to the user; Not textual match.">(@result.PopularityIndex)</small>
            </div>
            <div>
                <h4>
                    @result.Id
                </h4>
                <div class="grid">
                    @foreach (var indexedValue in result.IndexedValues)
                    {
                        <b title="Has weight @indexedValue.Weight"> @indexedValue.Name</b>
                        <div>
                            @if (indexedValue.TermMatches is not { } matches)
                            {
                                @indexedValue.Content
                            }
                            else
                            {
                                @for (int i = 0; i < indexedValue.Content.Length; i++)
                                {
                                    if (matches.FirstOrDefault(m => i == m.Position) is { } match && match.Length is not 0)
                                    {
                                        int offset = 0;
                                        for (int j = 0; j < match.ExpandedCigar.Length && i + j + offset < indexedValue.Content.Length; j++)
                                        {
                                            if (match.ExpandedCigar[j] is EditType.Match)
                                            {
                                                <span style="background-color:#9F9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.MisMatch)
                                            {
                                                <span style="background-color:#EE9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.Insert)
                                            {
                                                <span style="background-color:#EE9;">@indexedValue.Content[i + j + offset]</span>
                                            }
                                            else if (match.ExpandedCigar[j] is EditType.Delete)
                                            {
                                                offset--;
                                            }
                                        }
                                        i += match.Length - 1;
                                    }
                                    else
                                    {
                                        int nextMatch = matches.FirstOrDefault(m => m.Position >= i).Position;
                                        if (nextMatch != 0)
                                        {
                                            <span>@indexedValue.Content[i..(nextMatch)]</span>
                                            i = nextMatch - 1;
                                        }
                                        else
                                        {
                                            <span>@indexedValue.Content[i..]</span>
                                            i = indexedValue.Content.Length;
                                        }
                                    }
                                }
                            }
                        </div>
                    }
                </div>
            </div>
        }
    </div>
}

